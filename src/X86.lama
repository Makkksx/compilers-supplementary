import Data;
import SM;
import Collection;
import List;
import Buffer;
import Fun;

var regs = ["%ebx", "%ecx", "%esi", "%edi", "%eax", "%edx", "%ebp", "%esp"];

var nRegs = regs.length - 5;

var ebx = R(0),
    ecx = R(1),
    esi = R(2),
    edi = R(3),
    eax = R(4),
    edx = R(5),
    ebp = R(6),
    esp = R(7);

var wordSize = 4;

fun insnString(insn) {

  fun binopString(op) {
    case op of
        "+"   -> "addl"
      | "-"   -> "subl"
      | "*"   -> "imull"
      | "&&"  -> "andl"
      | "!!"  -> "orl"
      | "^"   -> "xorl"
      | "cmp" -> "cmpl"
    esac
  }

  fun opndString(opnd) {
    case opnd of
        R (i) -> regs [i]
      | S (i) -> sprintf("-%d(%%ebp)", (i + 1) * wordSize)
      | M (x) -> x
      | L (i) -> sprintf("$%d", i)
    esac
  }

  case insn of
      Cltd               -> "\tcltd\n"
    | Set   (suf, s)     -> sprintf("\tset%s\t%s\n", suf, s)
    | IDiv  (s1)         -> sprintf("\tidivl\t%s\n", opndString(s1))
    | Binop (op, s1, s2) -> sprintf("\t%s\t%s,\t%s\n", binopString(op), opndString(s1), opndString(s2))
    | Mov   (s1, s2)     -> sprintf("\tmovl\t%s,\t%s\n", opndString(s1), opndString(s2))
    | Push  (s)          -> sprintf("\tpushl\t%s\n", opndString(s))
    | Pop   (s)          -> sprintf("\tpopl\t%s\n", opndString(s))
    | Ret                -> "\tret\n"
    | Call  (p)          -> sprintf("\tcall\t%s\n", p)
    | Meta  (m)          -> m
  esac
}

fun makeEnv(stack, stackSlots, globals) {
  -- Returns an internal name for a global variable
  fun globalName(name) {
    "global_" ++ name
  }

  fun envString() {
    sprintf("Stack     : %s\nStackSlots: %d\nGlobals   : %s\n", stack.string, stackSlots, elements(globals).string)
  }

  fun allocate() {
    case
      case stack of
          {}        -> [ebx, 0]
        | S (n) : _ -> [S(n + 1), n + 2]
        | R (n) : _ -> if n < nRegs then [R(n + 1), stackSlots] else [S(0), 1] fi
        | _         -> [S(0), 1]
      esac
    of [x, n] -> [x, makeEnv(x:stack, if n > stackSlots then n else stackSlots fi, globals)]esac
  }

  fun push(y) {
    makeEnv(y:stack, stackSlots, globals)
  }

  fun pop() {
    case stack of
      x : stack -> [x, makeEnv(stack, stackSlots, globals)]
    esac
  }

  fun pop2() {
    case stack of
      x : y : stack -> [x, y, makeEnv(stack, stackSlots, globals)]
    esac
  }

  fun addGlobal(name) {
    makeEnv(stack, stackSlots, addSet(globals, globalName(name)))
  }

  fun loc(name) {
    M(globalName(name))
  }

  fun getGlobals() {
    globals.elements
  }

  fun getStackSize() {
    stackSlots
  }

  [envString, allocate, push, pop, pop2, addGlobal, loc, getGlobals, getStackSize]
}

fun envString(env) {
  env[0]()
}

fun allocate(env) {
  env[1]()
}

fun push(env, x) {
  env[2](x)
}

fun pop(env) {
  env[3]()
}

fun pop2(env) {
  env[4]()
}

fun addGlobal(env, name) {
  env[5](name)
}

fun loc(env, name) {
  env[6](name)
}

fun getGlobals(env) {
  env[7]()
}

fun getStackSize(env) {
  env[8]()
}

fun initEnv() {
  makeEnv(0, 0, emptySet(compare))
}

fun codeSection(text) {
  singletonBuffer(Meta("\t.text\n")) <+> text
}

fun dataSection(text) {
  singletonBuffer(Meta("\t.data\n")) <+> text
}

fun dataDef(name) {
  Meta(sprintf("%s:\t.int\t0\n", name))
}

fun prologue(size) {
  singletonBuffer(Push(ebp)) <+
    Mov(esp, ebp) <+
    Binop("-", L(wordSize * size), esp)
}

fun epilogue() {
  singletonBuffer(Mov(ebp, esp)) <+
    Pop(ebp) <+
    Binop("^", eax, eax) <+
    Ret
}

fun stackOpnd(opnd) {
  case opnd of
      S (_) -> true
    | _     -> false
  esac
}

fun memOpnd(opnd) {
  case opnd of
      S (_) -> true
    | M (_) -> true
    | _     -> false
  esac
}

fun move(from, to) {
  if memOpnd(from) && memOpnd(to)
    then singletonBuffer(Mov(from, eax)) <+ Mov(eax, to)
    else singletonBuffer(Mov(from, to))
  fi
}

fun suffix(op) {
  case op of
      "<"  -> "l"
    | "<=" -> "le"
    | "==" -> "e"
    | "!=" -> "ne"
    | ">=" -> "ge"
    | ">"  -> "g"
  esac
}

fun compile(env, code) {
  foldl(
    fun ([env, scode], i) {
      var code = scode <+ Meta("# " ++ showSMInsn(i) ++ "\n");
      case i of
          READ ->
          case env.allocate of
            [s, env] -> [env, code <+ Call("Lread") <+ Mov(eax, s)]
          esac
        | WRITE ->
          case env.pop of
            [s, env] -> [env, code <+ Push(s) <+ Call("Lwrite") <+ Pop(eax)]
          esac
        | CONST (int) ->
          case env.allocate of
            [s, env] -> [env, code <+> move(L(int), s)]
          esac
        | LD (name) ->
          case env.addGlobal(name).allocate of
            [s, env] -> [env, code <+> move(env.loc(name), s)]
          esac
        | ST (name) ->
          case env.addGlobal(name).pop of
            [s, env] -> [env, code <+> move(s, env.loc(name))]
          esac
        | BINOP (name) ->
          case env.pop2 of
            [r, l, env] -> [
              env.push(r),
              code <+> case name of
                  "+"  -> simpleOp(name, l, r)
                | "*"  -> simpleOp(name, l, r)
                | "-"  -> simpleOp(name, r, l) <+> move(l, r)
                | "/"  -> divOp(name, l, r)
                | "%"  -> divOp(name, l, r)
                | "&&" -> binaryOp(name, l, r)
                | "!!" -> binaryOp(name, l, r)
                | cmp  -> simpleOp("cmp", r, l) <+> setOperand(suffix(cmp), r)
              esac
            ]
          esac

      esac
    }, [env, emptyBuffer()], getBuffer(code))
}

fun simpleOp(name, l, r) {
  case l of
    R (_) -> Binop(name, l, r).singletonBuffer
    | _   -> { Mov(r, eax), Binop(name, l, eax), Mov(eax, r) }.listBuffer
  esac
}

fun divOp(name, l, r) {
  var reg = if name === "/" then eax else edx fi;
  { Mov(l, eax), Cltd, IDiv(r), Mov(reg, r) }.listBuffer
}

fun binaryOp(name, l, r) {
  fun transform(src) {
    Binop("cmp", L(0), src).singletonBuffer <+> setOperand("g", src)
  }

  transform(l) <+> transform(r) <+> simpleOp(name, l, r)
}

fun setOperand(suffix, src) {
  { Mov(L(0), eax), Set(suffix, "%al"), Mov(eax, src) }.listBuffer
}

public fun compileX86(code) {
  case compile(initEnv(), code) of
    [env, code] ->
      map(insnString,
        getBuffer $
          singletonBuffer(Meta("\t.global\tmain\n")) <+>
          dataSection(listBuffer $ map(dataDef, getGlobals(env))) <+>
          codeSection(
            singletonBuffer(Meta("main:\n")) <+>
              prologue(getStackSize(env)) <+>
              code <+>
              epilogue()
          )
      ).stringcat
  esac
}